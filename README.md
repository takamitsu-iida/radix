# radix tree

key, valueペアを保持するデータ構造です。
キーに合致する値だけでなく、キーに対してロンゲストマッチ方式で一致する情報を取り出せます。


## 参考文献

english
https://en.wikipedia.org/wiki/Radix_tree

japanese
https://ja.wikipedia.org/wiki/%E5%9F%BA%E6%95%B0%E6%9C%A8


## 実装メモ

自分でもすぐに忘れてしまうのでメモを残します。

ツリー構造自体はWikipediaの説明と同じですが、エッジの部分の実装が若干異なっています。

![wikipedia](https://ja.wikipedia.org/wiki/%E3%83%95%E3%82%A1%E3%82%A4%E3%83%AB:Patricia_trie.svg, "radix tree")


### Tree

```go
type Tree struct {
	root *node
	size int
}
```

- `root`

ルートノードです。
ルートノードからエッジが伸びていきます。

- `size`

Tree内に格納されているkey, valueペア（リーフ）の数です。

### leaf

```go
type leaf struct {
	key string
	val interface{}
}
```

key, valueペアを保持する構造体です。
leafを作成するとTreeのsizeを+1し、削除すると-1します。

### node

```go
type node struct {
	leaf *leaf
	prefixes []rune
	edges edges
}
```

- `leaf`

ノードが値を保持する場合は、リーフを作成し、そこへのポインタを保持します。
リーフを持たない場合、leafはnilになります。

- `prefixes`

このノードにたどり着くまでの共通部分を除いたユニーク部分です。
keyがUTF-8の場合を想定してruneのスライスです。

- `edges`

このノードから分岐していくエッジを格納するスライスです。
常に辞書順にソートされています。

### edges

```go
type edges []edge
```

このノードから分岐していく枝（エッジ）を格納したスライスです。

### edge

type edge struct {
	label rune
	node  *node
}

- `label`

このエッジを識別するrune型の単一文字です。
アルファベットしか扱わないのであれば26文字×大文字小文字で52本の枝がノードから分岐します。
ノードから分岐するエッジは常に辞書順にソートされているので、この文字を使って探し当てるのは簡単です。

- `node`

そのエッジの先にいるノード、つまり子ノードです。


### ツリー構造のイメージ

```txt
[node]--+--(edge)--[node]
        +--(edge)--[node]
        +--(edge)--[node]
```


例えば、

- romance
- romanus
- romulus
- rubens

をキーとして格納することを考えます。

rommanceの先頭はrですので、ルートノードからラベルrを持ったエッジを探しますが、まだ何も格納されていないので見つかりません。
ラベルrを持ったエッジを新規に作成してルートノードにぶら下げます。
子ノード[rommance]も新規に作成してエッジにぶら下げます。

```txt
root-(r)-[romance]
```

次にromanusを加えるとします。

romanusの先頭文字はrですので、ラベルrを持ったエッジを探します。
今度はすでに存在しますので、その先の子ノード[romance]に到達します。

[romance]が持つプレフィクスと探索中のromanusを比較します。共通部分を取り出すとromanです。
すでにある[romance]を共通部分である[roman]と、ユニークな部分である[ce]に分割します。
探索中のromanusはユニークな部分を取り除き[us]というノードを作ります。

```txt
root-(r)-[roman]-+-(c)-[ce]
                 |
                 +-(u)-[us]
```

次にromulusを加えるとします。

romulusはrで始まりますので、ラベルrを持ったエッジを探し、その先の子ノード[roman]を見つけます。
[roman]とromulusで共通部分を取り出すとromになります。
すでにある[roman]を二つに分割し、共通部分の[rom]とユニーク部分の[an]に分けます。
探索中のromulusはユニークな部分を取り出して[ulus]というノードを作ります。

```txt
root-(r)-[rom]-+-(a)-[an]-+-(c)-[ce]
               |          |
               |          +-(u)-[us]
               |
               +-(u)-[ulus]
```

次にrubensを加えるとします。

rubensの先頭文字はrですので、ラベルrを持ったエッジを探します。
この場合はすでに存在しますので、その先の子ノード[rom]に到達します。
[rom]とrubensで共通部分を取り出すとrになります。
すでにある[rom]を二つに分割し、共通部分の[r]とユニーク部分の[om]に分けます。
探索中のrubensはユニークな部分を取り出して[ubens]というノードを作ります。

最終的にはこのようなツリー構造になります。

```txt
root-(r)-[r]-+-(o)-[om]-+-(a)-[an]-+-(c)-[ce]
             |          |          |
             |          |          +-(u)-[us]
             |          |
             |          +-(u)-[ulus]
             |
             +-(u)-[ubens]
```

rootノードからはエッジが一つだけ伸びていてラベルは(r)です。

その子ノードは[r]で、プレフィクスrを持ちます。
[r]は中間ノードなのでリーフを持ちません。
[r]からは2本のエッジが伸びています。一つはラベル(o)を、もう一つはラベル(u)を持ちます。

ラベル(o)のエッジの先には子ノード[om]がいます。これも中間ノードなのでリーフを持ちません。
[om]からは2本のエッジが伸びています。一つはラベル(a)を、もう一つは(u)を持ちます。

ラベル(a)のエッジの先には子ノード[an]がいます。
[an]は中間ノードなのでリーフを持ちません。
[an]からは2本のエッジが伸びています。一つはラベル(c)を、もう一つは(u)を持ちます。

ラベル(c)の先には子ノード[ce]がいます。これはリーフでkey-valueペアを持ち、キーはrommanceです。

このようにツリーを探索しながらキーを挿入するわけです。

### 探索の実装

ツリーに格納しているkey-valueペアを探し当てるには、key文字列をruneのスライスに変換して、探索キーを生成します。
探索キーと、ツリー内のノードのプレフィクスを比較して、共通する部分を探索キーから削っていきます。
これを繰り返していって、探索キーの長さがゼロになったら、格納しているkey-valueペアのノードにたどり着いたことになります。

たとえば、前述のツリーのなかにあるromanceを探索するとします。

ノード[r]に到達すると探索キーはrを削除してomanceになります。ノード[om]に到達すると探索キーはomを削除してanceになります。ノード[an]に到達すると探索キーは[ce]になります。ノード[ce]に到達すると探索キーはなくなります。この状態になれば、リーフrommanceを持つノードに到達したことになります。

探索キーの長さがゼロではないのに次の子ノードが見つからない場合、それは探しているkey-valueペアのキーがツリーに格納されていないということです。
最も深いところまで探索した時点でのノード情報を返却するようにすれば、ロンゲストマッチでの探索になります。
